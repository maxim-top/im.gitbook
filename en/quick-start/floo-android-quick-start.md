# Android SDK Quick Start

This page is for quick integration, visit [detailed documentation](../reference/floo-android.md)

### Android SDK integration guide

### SDK architecture

Lanying IM SDK (codename floo) is implemented in C++, and each platform (Android, iOS, Linux, etc.) is encapsulated on this basis to complete the development of local library, so as to achieve the purpose of multi-platform reuse and keep the consistency of cross-platform protocol implementation. Floo-Android, as a native application library for Android, has two APIs available to developers, namely, low-level API and high-level API, in other words synchronous interface and asynchronous interface.

#### Low level API (low-level)

Synchronous interface, the class name ends with Service, which is represented by L/S in the following description for easier understanding, where L stands for Low-level and S for Sync.

As mentioned earlier, floo-android entity is [SWIG](http://www.swig.org/index.php) generated by framework automatically. Its java code is generated by SWIG, invokes the underlaying C++ class library by JNI, so most interfaces are synchronous, that is, the result is returned after interface invoked.

In code generation and transformation process, related data structures are directly mapped to the underlying class library for reducing memory copies, so its performance is close to calling the underlying library directly.

Synchronous service classes are as follows:

```
- BMXClient: SDK aggregation class, which contains all service classes and implements network event listening interface
- BMXChatService: message sending, message history retrieval, conversation list
- BMXUserService: Register account, login, logout, my settings
- BMXRosterService: Friend list, blacklist
- BMXGroupService: Group management (create, dissolve, search, set, member management, invite, apply, accept, reject)
```

#### High level API (high-level)

Asynchronous interface, and the class name ends with Manager, which is represented by H/A for easier understanding, where H for High-level and A for Async.

We also re-encapsulated high-level API based on this class, using a more friendly data structure and completing asynchronous encapsulation for development integration.

Simply put, the related call performs specific actions on child thread (for example, searching for friends), and the current thread will return result directly without blocking. The result of the action is notified to the caller through a callback function, where the caller can handle business logic such as UI refresh.

Asynchronous service classes are as follows:

```
- BaseManeger:Manger: Manage basic classes
- ChatManager: Message sending, message history retrieval, conversation list
- UserManager: Register account, login, logout, my settings
- RosterManager: Friend list, blacklist
- BMXCallBack: Untyped interface callback
- BMXDataCallBack<T>: Generic type with data callback
```

#### Other tool classes

```
- BMXGroupServiceListener: Group event listening
- BMXUserServiceListener: User event listening
- BMXRosterServiceListener: Friend event listening
- BMXNetworkListener: Network event listening interface, implemented by BMXClient
- BMXConversation: Conversation
- BMXMessage: Message
- BMXGroup: Group
- BMXRosterItem roster item (friend, stranger, blacklist, former friend)
- BMXUserProfile: User information
```

#### Class library diagram as follows

```
                                                 +---> BMXUserService
                                                 |
                              +---------------+  +---> BMXChatService
                              |               |  |
                          +---+ Low-level API: L/S  +------> BMXRosterService
                          |   |               |  |
                          |   +---------------+  +---> BMXGroupService
                          |
                          |                         +---> BMXUserManager
                          |   +---------------+     |
+----------------------+  |   |               |     +---> BMXChatManager
|                      |  +---+ High-level API: H/A +-----+
| Lanying IM SDK: Floo +--+   |               |     +---> BMXRosterManager
|                      |  |   +---------------+     |
+----------------------+  |                         +---> BMXGroupManager
                          |
                          |                       +--->  BMXClient
                          |   +----------------+  |
                          |   |                |  +--->  BMXSDKConfig
                          +---+ Utility：Tool class +--+
                              |                |  +--->  BMXMessage
                              +----------------+  |
                                                  +--->  BMXConversation
                                                  |
                                                  +--->  BMXUserProfile
                                                  |
                                                  +--->  BMXGroup
                                                  |
                                                  +--->  BMXDevice
```

### Import SDK

Aar or jar + so formats are selectable in SDK import

#### aar format

* Download aar file to /libs in project
* Add dependency in the dependencies block of build.gradle file, refer to [lanying-im-android source](https://github.com/maxim-top/lanying-im-android/blob/master/app/build.gradle#L94)for the latest version.

```
implementation(name:'floo-android_2.3.1.20200428',ext:'aar')
implementation 'com.squareup.okhttp3:okhttp:3.12.3'
implementation 'com.squareup.okio:okio:1.12.0'
```

#### jar+so format

* Download jar package and so library to /lib in project
* Add implementation fileTree(dir: ‘libs’, include: \[’\*.jar’]) to build.gradle file

### Permission configuration

Add permissions as follows in AndroidManifest.xml:

```
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_CONTACTS" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
```

### APP obfuscation

```
Add -keep class im.floo.floolib.**{*;} in ProGuard file
```

### Quick integration

#### BMXClient initialization

**Step 1 Import so library file**

Add import to app entry class

```
    static {
        System.loadLibrary("floo");
    }
```

**Step 2 - Initialize BMXClient**

```
    // Set storage path
    String appPath = AppContextUtils.getAppContext().getFilesDir().getPath();
    File dataPath = new File(appPath + "/data_dir");
    File cachePath = new File(appPath + "/cache_dir");
    dataPath.mkdirs();
    cachePath.mkdirs();

	// Set ID for push platform
    String pushId = getPushId();

    // Set sdk config
    BMXSDKConfig config = new BMXSDKConfig(BMXClientType.Android, "1", dataPath.getAbsolutePath(),
                cachePath.getAbsolutePath(), TextUtils.isEmpty(pushId) ? "MaxIM" : pushId);
    config.setConsoleOutput(true);
    config.setLogLevel(BMXLogLevel.Debug);

	// Initialize BMXClient
    BMXClient bmxClient = BMXClient.create(conf);
```

Note: If you use a High-level API (asynchronous invocation), following methods are required to get the service class API entity:

```
- ChatManager: Get message’s manager object via bmxClient.getChatManager().
- UserManager: Get user’s manager object via bmxClient.getUserManager().
- GroupManager: Get group’s manager object via bmxClient.getGroupManager().
- RosterManager: Get roster’s manager object via bmxClient.getRosterManager().
```

#### Register user

L/S: BMXUserProfile object reference is passed in and synchronous called, after which the profile is retrieved.

```
   bmxClient.signUpNewUser("zhangsan", "sFo!slk1x", new BMXUserProfile());
```

H/A: Asynchronous call on BMXDataCallBackReturn profile instance in callback.

```
   bmxClient.getUserManager().signUpNewUser("zhangsan", "sFo!slk1x", new BMXDataCallBack<BMXUserProfile>(){
        @Override
        public void onResult(BMXErrorCode bmxErrorCode, BMXUserProfile bmxUserProfile) {
           //Return profile
        }
   	});
```

#### Login

Two login modes: One is normal manual login, which involves getting the token and establishing a tcp connection; the other is quick login, which caches the token locally.

L/S: Success is judged by the value of returned BMXErrorCode.

```
	// Parameter：username password
   bmxClient.getUserService().signInByName("zhangsan", "sFo!slk1x");
   bmxClient.getUserService().fastSignInByName("zhangsan", "sFo!slk1x");
```

H/A: Success is judge by the returned BMXErrorCode in BMXCallBack.

```
   bmxClient.getUserManager().signInByName("zhangsan", "sFo!slk1x", new BMXCallBack(){
   	      @Override
          public void onResult(BMXErrorCode bmxErrorCode) {

          }
   	});
   bmxClient.getUserManager().signInByName("zhangsan", "sFo!slk1x", new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {

          }
   	});
```

#### Get conversation list

L/S: BMXConversationList object reference is passed in and called, after which the conversation list is retrieved.

```
   BMXConversationList cl = bmxClient.getChatService().getAllConversations();
   for (int i=0; i<cl.size(); i++){
       BMXConversation c = cl.get(i);
       Log.e("conversation id:",""+c.conversationId());
   }
```

H/A: From BMXDataCallBackto get conversation list.

```
   bmxClient.getChatManager().getAllConversations(new BMXDataCallBack<BMXConversationList>() {
       @Override
        public void onResult(BMXErrorCode bmxErrorCode, BMXConversationList list) {
          //Return BMXConversation instance
          for (int i=0; i<cl.size(); i++){
            BMXConversation c = cl.get(i);
            Log.e("conversation id:",""+c.conversationId());
          }
        }
   });
```

#### Disconnect

L/S: Success is judged by the value of returned BMXErrorCode.

```
bmxClient.getUserService().signOut();
```

H/A: Judged by BMXErrorCode in BMXCallBack.

```
   bmxClient.getUserManager().signOut(new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode
          }
   	});
```

### User system

* Add friend

> L/S: BMXErrorCode is retrieved to determine success. Parameter description: RosterId reason

```
   bmxClient.getRosterService().apply(22342342, "Hi, I'm Lisi");
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getRosterManager().apply(22342342, "Hi, I'm Lisi", new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode
          }
   	});
```

* Delete friend

> L/S: Success is judged by the value of returned BMXErrorCode.

```
   bmxClient.getRosterService().remove(22342342);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getRosterManager().remove(22342342, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode
          }
   	});
```

* Agree to add friend

> L/S: Success is judged by the value of returned BMXErrorCode.

```
   //Parameter description: rosterId
   bmxClient.getRosterService().accept(333453112);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getRosterManager().accept(333453112, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode
          }
   	});
```

* Reject to add friend

> L/S: Success is judged by the value of returned BMXErrorCode.

```
   //Parameter description: rosterId reason

   bmxClient.getRosterService().decline(333453112,"I'm not Lisi");
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getRosterManager().decline(333453112,"I'm not Lisi", new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
             //Return BMXErrorCode
          }
   	});
```

* Get rosterId

> L/S: ListOfLongLong object reference is passed in and called, after which the rosterId list is retrieved.

```
   ListOfLongLong roster = new ListOfLongLong();
   bmxClient.getRosterService().get(roster, true);
   for (int i=0; i<roster.size(); i++){
       long roster_id = roster.get(i);
       Log.e("roster id:",""+roster_id);
   }
```

> H/A: From BMXDataCallBackGet rosterID list in callback.

```
   bmxClient.getRosterManager().get(roster, true, new BMXDataCallBack<ListOfLongLong>(){
         @Override
         public void onResult(BMXErrorCode bmxErrorCode, ListOfLongLong list) {
            //Return ListOfLongLong instance
            for (int i=0; i<list.size(); i++){
              long roster_id = list.get(i);
              Log.e("roster id:",""+roster_id);
            }
        }
   });
```

### Basic features

#### Single chat

Single chat refers to one-to-one chat function, BMXConversationType of single chat is BMXConversationSingle, and toId refers to userId of single chat object.

#### Group chat

Group chat refers to the chat function of internal broadcast mode within the user set with roles and permissions, BMXConversationType is BMXConversationGroup, and toId refers to group Id.

#### Group management

* Create group

> L/S: BMXGroup object reference is passed in and called, after which the group information is retrieved.

```
    //Parameter description: option(group configuration)  group(group information)

    BMXGroupService.CreateGroupOptions options = new BMXGroupService.CreateGroupOptions(name, desc, publicCheckStatus);
    options.setMMembers(members);

    BMXGroup group = new BMXGroup();
    bmxClient.getGroupService().create(options, group);
```

> H/A: From BMXDataCallBackGet group information in callback.

```
   bmxClient.getGroupManager().create(option, new BMXDataCallBack<BMXGroup>(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode, BMXGroup group) {
            //Return BMXGroup instance
          }
   	});
```

* Join group

> L/S: Success is judged by the value of returned BMXErrorCode.

```
	//Parameter description: group(group information)  message(reason for membership application)
    bmxClient.getGroupService().join(group, message);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getGroupManager().join(group, message, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode instance
          }
   	});
```

* Quit group Parameter description: group (group information)

> L/S: Success is judged by the value of returned BMXErrorCode.

```
   bmxClient.getGroupService().leave(group);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getGroupManager().leave(group, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode instance
          }
   	});
```

* Dissolve group

> L/S: Success is judged by the value of returned BMXErrorCode.

```
   //Parameter description: group (group information)
   bmxClient.getGroupService().destroy(group);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getGroupManager().destroy(group, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErrorCode instance
          }
   	});
```

* Get group member list

> L/S: BMXGroupMemberList object reference is passed in and called, after which the group member list is retrieved.

```
    //Parameter description: group (group information) forceRefresh (whether to pull from server)
    boolean forceRefresh = true;

    BMXGroupMemberList memberList = new BMXGroupMemberList();
    bmxClient.getGroupService().getMembers(group, memberList, forceRefresh);
```

> H/A: From BMXDataCallBackGet group member list in callback.

```
   bmxClient.getGroupManager().getMembers(group, forceRefresh, new BMXDataCallBack<BMXGroupMemberList>(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode, BMXGroupMemberList list) {
            //Return BMXGroupMemberList instance
          }
   	});
```

* Get group list

> L/S: BMXGroupList object reference is passed in and called, after which the group list is retrieved.

```
   //Parameter description: forceRefresh (whether to pull from server)
   BMXGroupList list = new BMXGroupList();
   bmxClient.getGroupService().search(list, true);
```

> H/A: From BMXDataCallBackGet group list in callback.

```
    bmxClient.getGroupManager().getGroupList(true, new BMXDataCallBack<BMXGroupList>(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode, BMXGroupList list) {
            //Return BMXGroupList instance
          }
    });
```

* Get group information

> L/S: BMXGroup object reference is passed in and called, after which the group information is retrieved.

```
	//Parameter description: groupId  forceRefresh(whether to pull from server)
   BMXGroup bmxGroup = new BMXGroup();
   bmxClient.getGroupService().search(mGroupId, bmxGroup, true);
```

> H/A: From BMXDataCallBackGet group information in callback.

```
   bmxClient.getGroupManager().getGroupList(mGroupId, true, new BMXDataCallBack<BMXGroup>(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode, BMXGroup group) {
            //Return BMXGroup instance
          }
   	});
```

### Message sending

You can't chat until you login successfully. When sending messages, single chat and group chat call the same unified interface, but the only difference is to set BMXConversationType.

#### Message remote push

Developer shall configure the certificate for remote push, apply for permission in code, and send the deviceToken to Lanying IM server. When receiver is not online, Lanying IM server will automatically send the message through remote push.

Note: The pushed content is determined by the pushContent field of the sending message interface. If this field is empty-valued when the built-in message is sent, the default content will be pushed; user-defined messages must set this field, otherwise they will not be pushed.

* deviceToken passed to Lanying IM interface

> L/S: Success is judged by the value of returned BMXErrorCode.

```
    //Parameter description: pushToken
    bmxClient.getUserService().bindDevice(pushToken);
```

> H/A: Get BMXErrorCode in BMXCallBack to determine success.

```
   bmxClient.getUserManager().bindDevice(pushToken, new BMXCallBack(){
          @Override
          public void onResult(BMXErrorCode bmxErrorCode) {
            //Return BMXErroeCode instance
          }
   	});
```

#### Message format

**Text message**

```
//Parameter description: from(sender id)  to(receiver id)  type(single/group chat type)  text(text-message)
BMXMessage msg = BMXMessage.createMessage(from, to, type, to, text);
```

**Image message**

```
//Parameter description: from(sender id)  to(receiver id)  type(single/group chat type)  w(image width)   h(image height)  path(local path of image)  size(image size)

BMXImageAttachment.Size size = new BMXMessageAttachment.Size(w, h);
BMXImageAttachment imageAttachment = new BMXImageAttachment(path, size);
BMXMessage msg = BMXMessage.createMessage(from, to, type, to, imageAttachment);
```

**File message**

Parameter description: from(sender id) to(receiver id) type(singe/group chat type) path(local path of file) name(file name)

```
BMXFileAttachment fileAttachment = new BMXFileAttachment(path, name);
BMXMessage msg = BMXMessage.createMessage(from, to, type, to, fileAttachment);
```

**Location message**

Parameter description: from(sender id) to(receiver id) type(single/group chat type) latitude longitude address

```
BMXLocationAttachment locationAttachment = new BMXLocationAttachment(latitude, longitude, address);
BMXMessage msg = BMXMessage.createMessage(from, to, type, to, locationAttachment);
```

**Voice message**

Parameter description: from(sender id) to(receiver id) type(single/group chat type) path(local path of voice) time(voice length)

```
BMXVoiceAttachment voiceAttachment = new BMXVoiceAttachment(path, time);
BMXMessage msg = BMXMessage.createMessage(from, to, type, to, voiceAttachment);
```

#### Message operation

* Send

> L/S:

```
    // Parameter description: BMXMessage(message body)
    bmxClient.getChatService().sendMessage(msg);
```

> H/A:

```
    //Message sending status, required to register message receiving listener
    bmxClient.getChatManager().sendMessage(msg);
```

* Forward

> L/S:

```
	// Parameter description: BMXMessage(message body)
   bmxClient.getChatService().forwardMessage(msg);
```

> H/A:

```
    //Message sending status, required to register message receiving listener
	// Parameter description: BMXMessage(message body)
    bmxClient.getChatManager().forwardMessage(msg);
```

* Resend

> L/S:

```
   // Parameter description: BMXMessage(message body)
   bmxClient.getChatService().resendMessage(msg);
```

> H/A:

```
    //Message sending status, required to register message receiving listener
    bmxClient.getChatManager().resendMessage(msg);
```

* Revoke

> L/S:

```
	// Parameter description: BMXMessage(message body)
    bmxClient.getChatService().recallMessage(msg);
```

> H/A:

```
    //Message sending status, required to register message receiving listener
    bmxClient.getChatManager().recallMessage(msg);
```

* Download message attachment

Call instruction: pass in the download url in FileCallBack, onProgress for download progress, onFail returned for download failure, and onFinish returned for download successfully with the path.

```
    bmxClient.getChatManager().downloadAttachment(message, new FileCallback(body.url()) {
        @Override
        protected void onProgress(long percent, String path, boolean isThumbnail) {
        }

        @Override
        protected void onFinish(String url, boolean isThumbnail) {
            BMImageLoader.getInstance().display(mImageView, "file://" + body.path(), mImageConfig);
        }

        @Override
        protected void onFail(String path, boolean isThumbnail) {
        }
    });
```

### Message delivery listening

* Register message callback

```
private BMXChatServiceListener mChatListener = new BMXChatServiceListener() {

    @Override
    public void onStatusChanged(BMXMessage msg, BMXErrorCode error) {
    //Message status update
    }

    @Override
    public void onAttachmentStatusChanged(BMXMessage msg, BMXErrorCode error, int percent) {
    //Attachment status update
    }

    @Override
    public void onRecallStatusChanged(BMXMessage msg, BMXErrorCode error) {
    //Revoke status update
    }

    @Override
    public void onReceive(BMXMessageList list) {
    //Messages received
    }

    @Override
    public void onReceiveSystemMessages(BMXMessageList list) {
    //System notification received
    }

    @Override
    public void onReceiveReadAcks(BMXMessageList list) {
    //Read acknowledgement received
    }

    @Override
    public void onReceiveDeliverAcks(BMXMessageList list) {
    //Message delivery acknowledgement received
    }

    @Override
    public void onReceiveRecallMessages(BMXMessageList list) {
    //Message revocation notification received
    }

    @Override
    public void onAttachmentUploadProgressChanged(BMXMessage msg, int percent) {
    //Attachment upload progress update
    }

};
```

### Advanced features

BMXMessageObject entity provides extensible attributes (extensionJson and configJson), extensionJson is an extension field for development use, such as edit status; configJson is an extension field for SDK's own use, such as mention and push functions.

*   Group @ function

    @ function is supported in group, for meeting your @ specified user or @every member’s need, Developer shall set the config field in BMXMessage to implement group Owner’s @ function, the later @ actions will be notified by push

```
    // Text function: Add @ object
    if (atMap != null && !atMap.isEmpty()) {
        MentionBean mentionBean = new MentionBean();
        mentionBean.setSenderNickname(senderName);
        mentionBean.setPushMessage(pushText);
        // Stored information for @ object, including all or partial members
        if (atMap.containsKey("-1")) {
            // @all
            String atTitle = atMap.get("-1");
            if (!TextUtils.isEmpty(atTitle) && text.contains(atTitle)) {
                // @all if all are included, besides it is necessary to judge whether the text message contains the completed @ name. If not, @ will not be triggered.
                mentionBean.setMentionAll(true);
            }
        } else {
            // @partial members, need to traverse added @ information
            List<Long> atIds = new ArrayList<>();
            mentionBean.setMentionAll(false);
            for (Map.Entry<String, String> entry : atMap.entrySet()) {
                // Add this only if the sent text includes the name of @object, prevent the @object name in input box being modified
                if (entry.getValue() != null && !TextUtils.isEmpty(entry.getValue())
                    && text.contains(entry.getValue())) {
                    // @partial members, only feedId and userId are necessary in feed, so other useless information shall be removed
                    atIds.add(Long.valueOf(entry.getKey()));
                    }
                }
            mentionBean.setMentionList(atIds);
        }
        msg.setConfig(new Gson().toJson(mentionBean));
    }
```

* Typing message

```
    String INPUT_STATUS = "input_status";

    interface InputStatus {
        // Empty
        String NOTHING_STATUS = "nothing";

        // Key up
        String TYING_STATUS = "typing";
    }

    String extension = "";
    try {
        JSONObject object = new JSONObject();
        object.put(INPUT_STATUS,
            tag == MessageInputBar.OnInputPanelListener.TAG_OPEN
                    ? InputStatus.TYING_STATUS
                    : InputStatus.NOTHING_STATUS);
        extension = object.toString();
    } catch (JSONException e) {
        e.printStackTrace();
    }

    BMXMessage msg = BMXMessage.createMessage(from, to, type, to, "");
    if (msg == null) {
        return null;
    }
    msg.setDeliveryQos(BMXMessage.DeliveryQos.AtMostOnce);
    msg.setExtension(extension);
```
